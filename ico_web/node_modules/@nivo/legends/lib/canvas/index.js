'use strict';

exports.__esModule = true;
exports.renderLegendToCanvas = undefined;

var _compute = require('../compute');

var _BoxLegendSvg = require('../svg/BoxLegendSvg');

var _BoxLegendSvg2 = _interopRequireDefault(_BoxLegendSvg);

var _LegendSvg = require('../svg/LegendSvg');

var _LegendSvg2 = _interopRequireDefault(_LegendSvg);

var _LegendSvgItem = require('../svg/LegendSvgItem');

var _LegendSvgItem2 = _interopRequireDefault(_LegendSvgItem);

var _constants = require('../constants');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var textPropsMapping = {
    align: {
        start: 'left',
        middle: 'center',
        end: 'right'
    },
    baseline: {
        hanging: 'top',
        middle: 'middle',
        baseline: 'bottom'
    }
}; /*
    * This file is part of the nivo project.
    *
    * Copyright 2016-present, RaphaÃ«l Benitte.
    *
    * For the full copyright and license information, please view the LICENSE
    * file that was distributed with this source code.
    */
var renderLegendToCanvas = exports.renderLegendToCanvas = function renderLegendToCanvas(ctx, _ref) {
    var data = _ref.data,
        containerWidth = _ref.containerWidth,
        containerHeight = _ref.containerHeight,
        _ref$translateX = _ref.translateX,
        translateX = _ref$translateX === undefined ? _BoxLegendSvg2.default.defaultProps.translateX : _ref$translateX,
        _ref$translateY = _ref.translateY,
        translateY = _ref$translateY === undefined ? _BoxLegendSvg2.default.defaultProps.translateY : _ref$translateY,
        anchor = _ref.anchor,
        direction = _ref.direction,
        _ref$padding = _ref.padding,
        _padding = _ref$padding === undefined ? _LegendSvg2.default.defaultProps.padding : _ref$padding,
        _ref$justify = _ref.justify,
        justify = _ref$justify === undefined ? _LegendSvgItem2.default.defaultProps.justify : _ref$justify,
        itemWidth = _ref.itemWidth,
        itemHeight = _ref.itemHeight,
        _ref$itemDirection = _ref.itemDirection,
        itemDirection = _ref$itemDirection === undefined ? _LegendSvgItem2.default.defaultProps.direction : _ref$itemDirection,
        _ref$itemsSpacing = _ref.itemsSpacing,
        itemsSpacing = _ref$itemsSpacing === undefined ? _LegendSvg2.default.defaultProps.itemsSpacing : _ref$itemsSpacing,
        _ref$symbolSize = _ref.symbolSize,
        symbolSize = _ref$symbolSize === undefined ? _LegendSvgItem2.default.defaultProps.symbolSize : _ref$symbolSize,
        _ref$symbolSpacing = _ref.symbolSpacing,
        symbolSpacing = _ref$symbolSpacing === undefined ? _LegendSvgItem2.default.defaultProps.symbolSpacing : _ref$symbolSpacing;

    var _computeDimensions = (0, _compute.computeDimensions)({
        itemCount: data.length,
        itemWidth: itemWidth,
        itemHeight: itemHeight,
        itemsSpacing: itemsSpacing,
        direction: direction,
        padding: _padding
    }),
        width = _computeDimensions.width,
        height = _computeDimensions.height,
        padding = _computeDimensions.padding;

    var _computePositionFromA = (0, _compute.computePositionFromAnchor)({
        anchor: anchor,
        translateX: translateX,
        translateY: translateY,
        containerWidth: containerWidth,
        containerHeight: containerHeight,
        width: width,
        height: height
    }),
        x = _computePositionFromA.x,
        y = _computePositionFromA.y;

    var xStep = 0;
    var yStep = 0;
    if (direction === _constants.DIRECTION_ROW) {
        xStep = itemWidth + itemsSpacing;
    } else if (direction === _constants.DIRECTION_COLUMN) {
        yStep = itemHeight + itemsSpacing;
    }

    ctx.save();
    ctx.translate(x, y);

    data.forEach(function (d, i) {
        var itemX = i * xStep + padding.left;
        var itemY = i * yStep + padding.top;

        var _computeItemLayout = (0, _compute.computeItemLayout)({
            direction: itemDirection,
            justify: justify,
            symbolSize: symbolSize,
            symbolSpacing: symbolSpacing,
            width: itemWidth,
            height: itemHeight
        }),
            symbolX = _computeItemLayout.symbolX,
            symbolY = _computeItemLayout.symbolY,
            labelX = _computeItemLayout.labelX,
            labelY = _computeItemLayout.labelY,
            labelAnchor = _computeItemLayout.labelAnchor,
            labelAlignment = _computeItemLayout.labelAlignment;

        ctx.fillStyle = d.fill;
        ctx.fillRect(itemX + symbolX, itemY + symbolY, symbolSize, symbolSize);

        ctx.textAlign = textPropsMapping.align[labelAnchor];
        ctx.textBaseline = textPropsMapping.baseline[labelAlignment];
        ctx.fillStyle = '#000000';
        ctx.fillText(d.label, itemX + labelX, itemY + labelY);
    });

    ctx.restore();
};