var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

/*
 * This file is part of the nivo project.
 *
 * Copyright 2016-present, RaphaÃ«l Benitte.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
import { isNumber, isPlainObject } from 'lodash-es';
import { ANCHOR_BOTTOM, ANCHOR_BOTTOM_LEFT, ANCHOR_BOTTOM_RIGHT, ANCHOR_CENTER, ANCHOR_LEFT, ANCHOR_RIGHT, ANCHOR_TOP, ANCHOR_TOP_RIGHT, DIRECTION_BOTTOM_TO_TOP, DIRECTION_COLUMN, DIRECTION_LEFT_TO_RIGHT, DIRECTION_RIGHT_TO_LEFT, DIRECTION_ROW, DIRECTION_TOP_TO_BOTTOM } from './constants';

var zeroPadding = {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
};

export var computeDimensions = function computeDimensions(_ref) {
    var itemCount = _ref.itemCount,
        itemWidth = _ref.itemWidth,
        itemHeight = _ref.itemHeight,
        direction = _ref.direction,
        itemsSpacing = _ref.itemsSpacing,
        _padding = _ref.padding;

    var padding = void 0;
    if (isNumber(_padding)) {
        padding = {
            top: _padding,
            right: _padding,
            bottom: _padding,
            left: _padding
        };
    } else if (isPlainObject(_padding)) {
        padding = _extends({}, zeroPadding, _padding);
    } else {
        throw new TypeError('Invalid property padding, must be one of: number, object');
    }

    var horizontalPadding = padding.left + padding.right;
    var verticalPadding = padding.top + padding.bottom;
    var width = itemWidth + horizontalPadding;
    var height = itemHeight + verticalPadding;
    var spacing = (itemCount - 1) * itemsSpacing;
    if (direction === DIRECTION_ROW) {
        width = itemWidth * itemCount + spacing + horizontalPadding;
    } else if (direction === DIRECTION_COLUMN) {
        height = itemHeight * itemCount + spacing + verticalPadding;
    }

    return { width: width, height: height, padding: padding };
};

export var computePositionFromAnchor = function computePositionFromAnchor(_ref2) {
    var anchor = _ref2.anchor,
        translateX = _ref2.translateX,
        translateY = _ref2.translateY,
        containerWidth = _ref2.containerWidth,
        containerHeight = _ref2.containerHeight,
        width = _ref2.width,
        height = _ref2.height;

    var x = translateX;
    var y = translateY;

    switch (anchor) {
        case ANCHOR_TOP:
            x += (containerWidth - width) / 2;
            break;

        case ANCHOR_TOP_RIGHT:
            x += containerWidth - width;
            break;

        case ANCHOR_RIGHT:
            x += containerWidth - width;
            y += (containerHeight - height) / 2;
            break;

        case ANCHOR_BOTTOM_RIGHT:
            x += containerWidth - width;
            y += containerHeight - height;
            break;

        case ANCHOR_BOTTOM:
            x += (containerWidth - width) / 2;
            y += containerHeight - height;
            break;

        case ANCHOR_BOTTOM_LEFT:
            y += containerHeight - height;
            break;

        case ANCHOR_LEFT:
            y += (containerHeight - height) / 2;
            break;

        case ANCHOR_CENTER:
            x += (containerWidth - width) / 2;
            y += (containerHeight - height) / 2;
            break;
    }

    return { x: x, y: y };
};

export var computeItemLayout = function computeItemLayout(_ref3) {
    var direction = _ref3.direction,
        justify = _ref3.justify,
        symbolSize = _ref3.symbolSize,
        symbolSpacing = _ref3.symbolSpacing,
        width = _ref3.width,
        height = _ref3.height;

    var symbolX = void 0;
    var symbolY = void 0;

    var labelX = void 0;
    var labelY = void 0;
    var labelAnchor = void 0;
    var labelAlignment = void 0;

    switch (direction) {
        case DIRECTION_LEFT_TO_RIGHT:
            symbolX = 0;
            symbolY = (height - symbolSize) / 2;

            labelY = height / 2;
            labelAlignment = 'middle';
            if (justify === true) {
                labelX = width;
                labelAnchor = 'end';
            } else {
                labelX = symbolSize + symbolSpacing;
                labelAnchor = 'start';
            }
            break;

        case DIRECTION_RIGHT_TO_LEFT:
            symbolX = width - symbolSize;
            symbolY = (height - symbolSize) / 2;

            labelY = height / 2;
            labelAlignment = 'middle';
            if (justify === true) {
                labelX = 0;
                labelAnchor = 'start';
            } else {
                labelX = width - symbolSize - symbolSpacing;
                labelAnchor = 'end';
            }
            break;

        case DIRECTION_TOP_TO_BOTTOM:
            symbolX = (width - symbolSize) / 2;
            symbolY = 0;

            labelX = width / 2;

            labelAnchor = 'middle';
            if (justify === true) {
                labelY = height;
                labelAlignment = 'baseline';
            } else {
                labelY = symbolSize + symbolSpacing;
                labelAlignment = 'hanging';
            }
            break;

        case DIRECTION_BOTTOM_TO_TOP:
            symbolX = (width - symbolSize) / 2;
            symbolY = height - symbolSize;

            labelX = width / 2;
            labelAnchor = 'middle';
            if (justify === true) {
                labelY = 0;
                labelAlignment = 'hanging';
            } else {
                labelY = height - symbolSize - symbolSpacing;
                labelAlignment = 'baseline';
            }
            break;
    }

    return {
        symbolX: symbolX,
        symbolY: symbolY,

        labelX: labelX,
        labelY: labelY,
        labelAnchor: labelAnchor,
        labelAlignment: labelAlignment
    };
};