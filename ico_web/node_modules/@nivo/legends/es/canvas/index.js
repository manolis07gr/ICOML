/*
 * This file is part of the nivo project.
 *
 * Copyright 2016-present, RaphaÃ«l Benitte.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
import { computeDimensions, computePositionFromAnchor, computeItemLayout } from '../compute';
import BoxLegendSvg from '../svg/BoxLegendSvg';
import LegendSvg from '../svg/LegendSvg';
import LegendSvgItem from '../svg/LegendSvgItem';
import { DIRECTION_COLUMN, DIRECTION_ROW } from '../constants';

var textPropsMapping = {
    align: {
        start: 'left',
        middle: 'center',
        end: 'right'
    },
    baseline: {
        hanging: 'top',
        middle: 'middle',
        baseline: 'bottom'
    }
};

export var renderLegendToCanvas = function renderLegendToCanvas(ctx, _ref) {
    var data = _ref.data,
        containerWidth = _ref.containerWidth,
        containerHeight = _ref.containerHeight,
        _ref$translateX = _ref.translateX,
        translateX = _ref$translateX === undefined ? BoxLegendSvg.defaultProps.translateX : _ref$translateX,
        _ref$translateY = _ref.translateY,
        translateY = _ref$translateY === undefined ? BoxLegendSvg.defaultProps.translateY : _ref$translateY,
        anchor = _ref.anchor,
        direction = _ref.direction,
        _ref$padding = _ref.padding,
        _padding = _ref$padding === undefined ? LegendSvg.defaultProps.padding : _ref$padding,
        _ref$justify = _ref.justify,
        justify = _ref$justify === undefined ? LegendSvgItem.defaultProps.justify : _ref$justify,
        itemWidth = _ref.itemWidth,
        itemHeight = _ref.itemHeight,
        _ref$itemDirection = _ref.itemDirection,
        itemDirection = _ref$itemDirection === undefined ? LegendSvgItem.defaultProps.direction : _ref$itemDirection,
        _ref$itemsSpacing = _ref.itemsSpacing,
        itemsSpacing = _ref$itemsSpacing === undefined ? LegendSvg.defaultProps.itemsSpacing : _ref$itemsSpacing,
        _ref$symbolSize = _ref.symbolSize,
        symbolSize = _ref$symbolSize === undefined ? LegendSvgItem.defaultProps.symbolSize : _ref$symbolSize,
        _ref$symbolSpacing = _ref.symbolSpacing,
        symbolSpacing = _ref$symbolSpacing === undefined ? LegendSvgItem.defaultProps.symbolSpacing : _ref$symbolSpacing;

    var _computeDimensions = computeDimensions({
        itemCount: data.length,
        itemWidth: itemWidth,
        itemHeight: itemHeight,
        itemsSpacing: itemsSpacing,
        direction: direction,
        padding: _padding
    }),
        width = _computeDimensions.width,
        height = _computeDimensions.height,
        padding = _computeDimensions.padding;

    var _computePositionFromA = computePositionFromAnchor({
        anchor: anchor,
        translateX: translateX,
        translateY: translateY,
        containerWidth: containerWidth,
        containerHeight: containerHeight,
        width: width,
        height: height
    }),
        x = _computePositionFromA.x,
        y = _computePositionFromA.y;

    var xStep = 0;
    var yStep = 0;
    if (direction === DIRECTION_ROW) {
        xStep = itemWidth + itemsSpacing;
    } else if (direction === DIRECTION_COLUMN) {
        yStep = itemHeight + itemsSpacing;
    }

    ctx.save();
    ctx.translate(x, y);

    data.forEach(function (d, i) {
        var itemX = i * xStep + padding.left;
        var itemY = i * yStep + padding.top;

        var _computeItemLayout = computeItemLayout({
            direction: itemDirection,
            justify: justify,
            symbolSize: symbolSize,
            symbolSpacing: symbolSpacing,
            width: itemWidth,
            height: itemHeight
        }),
            symbolX = _computeItemLayout.symbolX,
            symbolY = _computeItemLayout.symbolY,
            labelX = _computeItemLayout.labelX,
            labelY = _computeItemLayout.labelY,
            labelAnchor = _computeItemLayout.labelAnchor,
            labelAlignment = _computeItemLayout.labelAlignment;

        ctx.fillStyle = d.fill;
        ctx.fillRect(itemX + symbolX, itemY + symbolY, symbolSize, symbolSize);

        ctx.textAlign = textPropsMapping.align[labelAnchor];
        ctx.textBaseline = textPropsMapping.baseline[labelAlignment];
        ctx.fillStyle = '#000000';
        ctx.fillText(d.label, itemX + labelX, itemY + labelY);
    });

    ctx.restore();
};